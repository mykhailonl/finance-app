const c=(a,o)=>a.filter(n=>n.name.toLowerCase().includes(o.toLowerCase())),m=(a,o,n=10)=>{const e=a.length,t=Math.ceil(e/n),r=Math.max(1,Math.min(o,t)),s=(r-1)*n,u=s+n;return{items:a.slice(s,u),totalPages:t,totalFilteredCount:e,currentPage:r,hasNext:r<t,hasPrev:r>1}},l=(a,o,n)=>{switch(o){case"alphAsc":return[...a].sort((e,t)=>e.name.toLowerCase().localeCompare(t.name.toLowerCase()));case"alphDesc":return[...a].sort((e,t)=>t.name.toLowerCase().localeCompare(e.name.toLowerCase()));case"latest":return n?[...a].sort((e,t)=>new Date(t.transaction_date).getDate()-new Date(e.transaction_date).getDate()):[...a].sort((e,t)=>new Date(t.transaction_date).getTime()-new Date(e.transaction_date).getTime());case"oldest":return n?[...a].sort((e,t)=>new Date(e.transaction_date).getDate()-new Date(t.transaction_date).getDate()):[...a].sort((e,t)=>new Date(e.transaction_date).getTime()-new Date(t.transaction_date).getTime());case"highest":return[...a].sort((e,t)=>{const r=Math.abs(t.amount)-Math.abs(e.amount);return r!==0?r:t.amount-e.amount});case"lowest":return[...a].sort((e,t)=>{const r=Math.abs(e.amount)-Math.abs(t.amount);return r!==0?r:t.amount-e.amount});default:return a}};export{c as f,m as p,l as s};
